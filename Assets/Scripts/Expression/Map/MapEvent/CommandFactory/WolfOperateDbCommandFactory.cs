using Util.Wolf;
using System;
using System.Collections.Generic;
using UnityEngine;// 【暫定】本来はExpressionレイヤはUnityEngineに依存しない。要設計見直し
using Infrastructure;

namespace Expression.Map.MapEvent.CommandFactory
{
    public class WolfOperateDbCommandFactory : WolfEventCommandFactoryInterface
    {
        public EventCommandBase Create(MetaEventCommand metaCommand)
        {
            //return new EventCommandBase();

            int typeNo = metaCommand.NumberArgs[1];
            int dataNo = metaCommand.NumberArgs[2];
            int fieldNo = metaCommand.NumberArgs[3];
            int operatorType = metaCommand.NumberArgs[4] & 0x0F;
            int targetDatabase = (metaCommand.NumberArgs[4] >> 8) & 0x0F;
            int modeType = (metaCommand.NumberArgs[4] >> 12) & 0x0F;
            int nameSpecifyConfig = (metaCommand.NumberArgs[4] >> 16) & 0x0F;
            int targetVal = metaCommand.NumberArgs.Length > 5 ? metaCommand.NumberArgs[5] : 0;// 数値か代入先変数

            // DBの参照を変数呼び出し値に変換する
            WolfConfig.DatabaseType dbType;
            {
                var loader = new WolfDatabaseLoader();
                switch (targetDatabase)
                {
                    case 0:
                        // 可変DB
                        dbType = WolfConfig.DatabaseType.Changable;
                        break;
                    case 1:
                        // システムDB
                        dbType = WolfConfig.DatabaseType.System;
                        break;
                    case 2:
                        // ユーザDB
                        dbType = WolfConfig.DatabaseType.User;
                        break;
                    default:
                        throw new Exception("不正なDBタイプを指定された");
                }
            }

            // 設定時は文字列でキーを指定していたとしても、データ上は数値に変換された状態で保持している。
            // このため、データ構成をロードして文字列で検索する処理は不要
            OperatorType assignType = GetAssignOperator(operatorType);
            Common.IDataAccessorFactory<int> targetAccessorFactory = new Command.WolfIntAccessorFactory(false, targetVal);
            Common.IDataAccessorFactory<int> databaseAccessorFactory
                = new Command.WolfIntRepositoryAccessorFactory(dbType, typeNo, dataNo, fieldNo);
            // 右辺第二項は固定。何もしない
            OperatorType rightOperatorType = OperatorType.Plus;
            Common.IDataAccessorFactory<int> rightAccessorFactory = new Command.WolfIntAccessorFactory(true, 0);

            if (modeType == 0)
            {
                // DBに代入
                UpdaterInt[] updaters = new UpdaterInt[1];
                updaters[0] = new UpdaterInt(databaseAccessorFactory, targetAccessorFactory, rightAccessorFactory,
                    assignType, rightOperatorType);

                return new ChangeVariableIntCommand(updaters);
            }
            else
            {
                // 変数に代入

                UpdaterInt[] updaters = new UpdaterInt[1];
                updaters[0] = new UpdaterInt(targetAccessorFactory, databaseAccessorFactory, rightAccessorFactory,
                    assignType, rightOperatorType);

                return new ChangeVariableIntCommand(updaters);
            }
        }

        private OperatorType GetAssignOperator(int value)
        {
            switch (value)
            {
                case 0x00:
                    return OperatorType.NormalAssign;
                case 0x01:
                    return OperatorType.PlusAssign;
                case 0x02:
                    return OperatorType.MinusAssign;
                case 0x03:
                    return OperatorType.MultiplyAssign;
                case 0x04:
                    return OperatorType.DivideAssign;
                case 0x05:
                    return OperatorType.ModAssign;
                case 0x06:
                    return OperatorType.MaxAssign;
                case 0x07:
                    return OperatorType.MinAssign;
                default:
                    return OperatorType.NormalAssign;
            }
        }

        private OperatorType GetCalculateOperator(int value)
        {
            switch (value)
            {
                case 0xF0:
                    return OperatorType.ArcTan;
                case 0x00:
                    return OperatorType.Plus;
                case 0x10:
                    return OperatorType.Minus;
                case 0x20:
                    return OperatorType.Multiply;
                case 0x30:
                    return OperatorType.Divide;
                case 0x40:
                    return OperatorType.Mod;
                case 0x50:
                    return OperatorType.And;
                case 0x60:
                    return OperatorType.Random;
                default:
                    return OperatorType.Plus;
            }
        }
    }
}
